summary(lm(y ~ W[,2]))
summary(lm(y ~ W[,3]))$coef[2,4]
a <- array()
for (i in 1:ncol(W)){
a[i] <- summary(lm(y ~ W[, i]))$coef[2,4]
}
for (i in 1:ncol(W)){
a[i] <- summary(lm(y ~ W[, i]))$coef[2,4]
}
which(a < 0.05)
a <- array()
for (i in 1:ncol(W)){
a[i] <- summary(lm(y ~ W[, i]))$coef[2,4]
}
which(a < 0.05)
library(qqman)
vignette('qqman')
?mice.X
?mice.X
mice.X
?mice.X
?mice
?mice
vignette('qqman')
str(gwasResults)
plot(-log10(a))
vignette('qqman')
plot(-log10(a), type="p")
plot(-log10(a), type="o")
plot(-log10(a), type="p", bg="red")
plot(-log10(a), type="p", bg="red")
plot(-log10(a), type="p", col="red")
plot(-log10(a), type="p", col="red", pch = 16)
plot(-log10(a), type="p", col="blue", pch = 16)
abline(y=7)
abline(a=7, b=0)
abline(a=7, b=0, col="red")
abline(a=7, b=0, col="red")
abline(h=0, col="red")
abline(a=7, b=0, col="red")
abline(a=7, b=0, col="red")
abline(h=7, col="red")
plot(-log10(a), type="p", col="blue", pch = 16)
plot(-log10(a), type="p", col="blue", pch = 16)
plot(-log10(a), type="p", col="blue", pch = 16)
abline(h=7, col="red")
library(synbreed)
install.packages("synbreed")
library(synbreed)
library(synbreed)
?catle
install.packages("synbreedData")
library(synbreedData)
?synbreedData
library(synbreedData)
data(cattle)
?cattle
head(1:5, )
cattle[1:5, ]
cattle
help(package = "synbreedData")
data(cattle)
pheno <- as.matrix(cattle$pheno[, 1, 1])
pheno
dim(cattle$geno)
geno <- codeGeno(cattle, impute = TRUE, impute.type = "random", reference.allele = "minor")
map <- catttle$map
map <- cattle$map
map
head(map)
geno[1:5,1:5]
geno
cattleC <- codeGeno(cattle, impute = TRUE, impute.type = "random", reference.allele = "minor")
W <- cattleC$geno
dim(W)
W[1:5, 1:5]
vignette('qqman')
library(devtools)
install_github('HaipengU/Connectedness')
library(Connectedness)
library(Connectedness)
install_github('HaipengU/Connectedness')
library(Connectedness)
install_github('HaipengU/Connectedness')
library(Connectedness)
?`Connectedness-package`
library(ggplot2)
?`ggplot2-package`
?`Connectedness-package`
data(cattle)
?cattle
head(cattle)
head(cattle.pheno)
head(cattle.X)
cattle.X[1:5, 1:5]
library(curl)
?curl
library(bookdown)
?bookdown_site
?bookdown
library(lme4)
?`lme4-package`
?`Connectedness-package`
vignette("concordance")
library(BGLR)
data(mice)
W <- mice.X
p <- colSums(W) / (2*nrow(W))
maf <- ifelse(p > 0.5, 1-p, p)
y <- mice.pheno$Obesity.BMI
a <- array()
for (i in 1:ncol(W)){
a[i] <- summary(lm(y ~ W[, i]))$coef[2,4]
}
which(a < 0.05)
library(qqman)
vignette('qqman')
str(gwasResults)
head(gwasResults)
-log10(0.05)
-log10(0.8)
as.data.frame(table(gwasResults$CHR))
manhattan(gwasResults)
vignette(qqman)
vignette("qqman")
manhattan(subset(gwasResults, CHR == 1))
manhattan(gwasResults)
a
vignette('qqman')
plot(-log10(a), type="p", col="blue", pch = 16)
abline(h=7, col="red")
plot(-log10(a), type="p", col="blue", pch = 16)
abline(h=7, col="red")
manhattan(gwasResults)
vignette('qqman')
manhattan(gwasResults, col = c("blue4", "orange3"))
manhattan(gwasResults)
manhattan(gwasResults, col = c("blue4", "orange3"))
library(synbreed)
library(synbreedData)
help(package = "synbreedData")
data(cattle)
`?`(cattle)
pheno <- as.matrix(cattle$pheno[, 1, 1])
dim(cattle$geno)
set.seed(100)
# Imputation
cattleC <- codeGeno(cattle, impute = TRUE, impute.type = "random", reference.allele = "minor")
# SNP matrix
W <- cattleC$geno
# Marker information
map <- cattle$map
y
lenght(y)
length(y)
length(pheno)
dim(W)
head(map
)
library(devtools)
install_github('HaipengU/Connectedness')
library(Connectedness)
library(Connectedness)
vignette(package="Connectedness")
vignette("Connectedness")
devtools::install_github(‘HaipengU/Connectedness’, build_opts = c(“--no-resave-data”, “--no-manual”))
devtools::install_github("HaipengU/Connectedness", build_opts = c(“--no-resave-data”, “--no-manual”))
devtools::install_github("HaipengU/Connectedness", build_opts = c(“--no-resave-data”, “--no-manual”))
devtools::install_github("HaipengU/Connectedness", build_opts = c(“--no-resave-data”, “--no-manual”))
devtools::install_github("HaipengU/Connectedness", build_opts = c("--no-resave-data", "--no-manual"))
devtools::install_github("HaipengU/Connectedness", build_opts = c("--no-resave-data", "--no-manual"), force=TRUE)
library(Connectedness)
library(Connectedness)
vignette(‘Connectedness’, package = ‘Connectedness’)
vignette("Connectedness", package = "Connectedness")
devtools::install_github("HaipengU/Connectedness", build_opts = c("--no-resave-data", "--no-manual"), force=TRUE)
install.package("prettydoc")
install.packages("prettydoc")
install.packages("prettydoc")
devtools::install_github("HaipengU/Connectedness", build_opts = c("--no-resave-data", "--no-manual"), force=TRUE)
vignette("Connectedness", package = "Connectedness")
vignette("Connectedness", package = "Connectedness")
install.packages("rmdformats")
vignette("Connectedness", package = "Connectedness")
vignette("Connectedness", package = "Connectedness")
vignette("Connectedness", package = "Connectedness")
lirary(Connectedness)
library(Connectedness)
vignette("Connectedness", package = "Connectedness")
?Connectedness
data(GCcattle)
dim(cattle.pheno)
head(cattle.pheno)
vignette('qqman')
head(map)
library(synbreed)
library(synbreedData)
help(package = "synbreedData")
data(cattle)
`?`(cattle)
pheno <- as.matrix(cattle$pheno[, 1, 1])
dim(cattle$geno)
set.seed(100)
# Imputation
cattleC <- codeGeno(cattle, impute = TRUE, impute.type = "random", reference.allele = "minor")
# SNP matrix
W <- cattleC$geno
# Marker information
map <- cattle$map
head(map)
vignette('qqman')
a <- array()
for (i in 1:ncol(W)){
a[i] <- summary(lm(pheno ~ W[, i]))$coef[2,4]
}
dim(W)
length(a)
a
# Manhattan
map2 <- data.frame(SNP = row.names(map), CHR=map$chr, BP=map$pos, P=a)
head(map2)
head(mapply(function, ...))
head(map)
?cattle
map$pos * 1000000
head(map$pos*1000000)
# Manhattan
map2 <- data.frame(SNP = row.names(map), CHR=map$chr, BP=map$pos*1000000, P=a)
head(map2)
manhattan(map2, main = "Manhattan Plot", ylim = c(0, 10), cex = 0.6,
cex.axis = 0.9, col = c("blue4", "orange3"), suggestiveline = TRUE, genomewideline = TRUE, chrlabs = c(1:20, "P", "Q"))
library(qqman)
manhattan(map2, main = "Manhattan Plot", ylim = c(0, 10), cex = 0.6,
cex.axis = 0.9, col = c("blue4", "orange3"), suggestiveline = TRUE, genomewideline = TRUE, chrlabs = c(1:20, "P", "Q"))
table(map2$CHR)
manhattan(map2, main = "Manhattan Plot", ylim = c(0, 10), cex = 0.6,
cex.axis = 0.9, col = c("blue4", "orange3"), suggestiveline = TRUE, genomewideline = TRUE, chrlabs = c(1:29))
manhattan(map2, main = "Manhattan Plot", ylim = c(0, 10), cex = 0.6,
cex.axis = 0.9, col = c("blue4", "orange3"), suggestiveline = TRUE, genomewideline = TRUE)
p.adjust(a, method="bonferroni")
a
library(BGLR)
data(mice)
W <- mice.X
p <- colSums(W) / (2*nrow(W))
maf <- ifelse(p > 0.5, 1-p, p)
y <- mice.pheno$Obesity.BMI
summary(lm(y ~ W[,1]))
summary(lm(y ~ W[,2]))
summary(lm(y ~ W[,3]))$coef[2,4]
a <- array()
for (i in 1:ncol(W)){
a[i] <- summary(lm(y ~ W[, i]))$coef[2,4]
}
which(a < 0.05)
# use the mice data
p.adjust(a, method="bonferroni")
p.adjust(a, method="fdr")
a2 <- p.adjust(a, method="fdr")
which(a2 < 0.1)
which(a2 < 0.05)
which(a2 < 0.05)
which(a2 < 0.1)
a[63]
W <- cattleC$geno
# Marker information
map <- cattle$map
a <- array()
for (i in 1:ncol(W)){
a[i] <- summary(lm(pheno ~ W[, i]))$coef[2,4]
}
# use the cattle data
a1 <- p.adjust(a, method="bonferroni")
which(a1 < 0.05)
a2 <- p.adjust(a, method="fdr")
which(a2 < 0.05)
a2
install.packages("rrBLUP")
library(rrBlUP)
library(rrBLUP)
a
length(a)
yhat <- W %*% matrix(a)
yhat
plot(y~yhat)
plot(pheno~yhat)
cor(pheno, yhat)
lm(pheno ~ W[, i])
summary(lm(pheno ~ W[, i]))$coef
a <- array()
for (i in 1:ncol(W)){
a[i] <- summary(lm(pheno ~ W[, i]))$coef[2,1]
}
yhat <- W %*% matrix(a)
plot(pheno~yhat)
cor(pheno, yhat)
source("
http://morotalab.org/Mrode2005/rr/stdtime.txt")
source("http://morotalab.org/Mrode2005/rr/stdtime.txt")
source("http://morotalab.org/Mrode2005/rr/legendre.txt")
stdtime(t, order)
t
t <- c(1:20)
order <- 2
stdtime(t, order)
Lambda <- legendre(order, gengler = FALSE)
Lambda
Phi <- M %*% Lambda
M <- stdtime(t, order)
Lambda <- legendre(order, gengler = FALSE)
Phi <- M %*% Lambda
Phi
M
Phi_trn <- Phi[1:15,]
Phi_trn
Phi_tst <- Phi[16:20,]
Phi_tst
Phi_trn
Phi_tst
Phi_tst1
Phi_trn1 <- Phi[1:15,]
Phi_trn1
Phi_tst1 <- Phi[16:20,]
Phi_tst1
# Real case
t <- c(1:15)
order <- 2
M <- stdtime(t, order)
Lambda <- legendre(order, gengler = FALSE)
Phi <- M %*% Lambda
Phi_trn
t <- c(1:5)
order <- 2
M <- stdtime(t, order)
Lambda <- legendre(order, gengler = FALSE)
Phi_tst <- M %*% Lambda
Phi_tst
t <- c(1:15)
order <- 2
M <- stdtime(t, order)
Lambda <- legendre(order, gengler = FALSE)
Phi_trn2 <- M %*% Lambda
Phi_trn2
t <- c(1:5)
order <- 2
M <- stdtime(t, order)
Lambda <- legendre(order, gengler = FALSE)
Phi_tst2 <- M %*% Lambda
Phi_tst2
# Comparison
Phi_trn1
Phi_trn2
Phi_tst1
Phi_tst2
library("sommer")
library("orthopolynom")
library("lattice")
library("data.table")
setwd("~/Dropbox/chikudaisei/teaching/2019/HUJI2019/day2")
GRM   <-as.matrix(read.table("G.txt",header = FALSE)) # Read files: Genomic relationship matix (GRM) and Phenotypes
Pheno <-read.table("Pheno.txt",header = TRUE)        # IDs should be factor not numeric
Pheno$ID<- factor(Pheno$ID)                       # Consider IDs as factors level
head(Pheno)
colnames(GRM) <- unique(Pheno$ID)                 # Link GRM columns to accessions IDs
rownames(GRM) <- unique(Pheno$ID)                 # Link GRM rows to accessions IDs
RRM.1 <-mmer(Y~1                                  # mmer function from sommer package && leg() from orthopolynom package, vs = variance structure, Gu = known covariance structures
,random=~vs(leg(Time, 2),ID,Gu=GRM) + vs(leg(Time, 2), Pe)
,rcov=~vs(units) # residuals, units = cov=~vs(ds(Time),units)
,data=Pheno)
names(RRM.1)
RRM.1$U
names(RRM.1$U)
RnReg_Q <- rbind(unlist(RRM.1$U$`leg0:ID`),         # extract estimated random regression coeifficeints
unlist(RRM.1$U$`leg1:ID`),         # Num. regression coefficients* Num. IDs. Dim is RnReg x nID = 3 x 89
unlist(RRM.1$U$`leg2:ID`))
colnames(RnReg_Q)<- unique(Pheno$ID)                # Assign IDs to columns
Time <- unique(Pheno$Time)                         # Create a quadratic Legendre's
Phi_Q <- leg(Time, 2)
Phi_L <- Phi_Q[,-3]
RnReg_L <- RnReg_Q[-3,]
GEBV_L <- t(apply(RnReg_L, 2, function (x) Phi_L %*% x)) # estimating GEBVs for each IDs using RanReg: GEBV= Phi%*%RnReg
GEBV2_L <- t(Phi_L %*% RnReg_L)
Pred_L <- cbind(Pheno, c(RRM.1$Beta$Estimate + GEBV_L))   # merge orginal phenotype and predicted values and compare using lattice xyplot() function
colnames(Pred_L)<- c("ID","Time","Observed","Predicted")
IDs.f <- c(1,9,10,15,31,32,36,51,52,56,62,63)      # First 12 IDs
# Prediction using linear Leg
xyplot(Predicted+Observed~Time|ID,type ="l",       # xyplot() function from the lattice package
data = Pred_L[which(Pred_L$ID%in%IDs.f),],  # To buil the appropriate plots
pch=1, cex=1, auto.key=T, ylab="Phenotype")
GEBV_Q <- t(apply(RnReg_Q, 2, function (x) Phi_Q %*% x)) # estimating GEBVs for each IDs using RanReg: GEBV= Phi%*%RnReg
GEBV2_Q <- t(Phi_Q %*% RnReg_Q)
Pred_Q <- cbind(Pheno, c(RRM.1$Beta$Estimate + GEBV_Q))   # merge orginal phenotype and predicted values and compare using lattice xyplot() function
colnames(Pred_Q)<- c("ID","Time","Observed","Predicted")
xyplot(Predicted+Observed~Time|ID,type ="l",       # xyplot() function from the lattice package
data = Pred_Q[which(Pred_Q$ID%in%IDs.f),],  # To buil the appropriate plots
pch=1,cex=.8,auto.key=T, ylab="Phenotype")
head(Pred_L)
RnReg_L <- RnReg_Q[-3,]
GEBV_L <- t(apply(RnReg_L, 2, function (x) Phi_L %*% x)) # estimating GEBVs for each IDs using RanReg: GEBV= Phi%*%RnReg
GEBV2_L <- t(Phi_L %*% RnReg_L)
Pred_L <- cbind(Pheno, c(RRM.1$Beta$Estimate + GEBV_L))   # merge orginal phenotype and predicted values and compare using lattice xyplot() function
colnames(Pred_L)<- c("ID", "Pe", "Time","Observed","Predicted")
IDs.f <- c(1,9,10,15,31,32,36,51,52,56,62,63)      # First 12 IDs
# Prediction using linear Leg
xyplot(Predicted+Observed~Time|ID,type ="l",       # xyplot() function from the lattice package
data = Pred_L[which(Pred_L$ID%in%IDs.f),],  # To buil the appropriate plots
pch=1, cex=1, auto.key=T, ylab="Phenotype")
GEBV_Q <- t(apply(RnReg_Q, 2, function (x) Phi_Q %*% x)) # estimating GEBVs for each IDs using RanReg: GEBV= Phi%*%RnReg
GEBV2_Q <- t(Phi_Q %*% RnReg_Q)
Pred_Q <- cbind(Pheno, c(RRM.1$Beta$Estimate + GEBV_Q))   # merge orginal phenotype and predicted values and compare using lattice xyplot() function
colnames(Pred_Q)<- c("ID", "Pe", "Time","Observed","Predicted")
xyplot(Predicted+Observed~Time|ID,type ="l",       # xyplot() function from the lattice package
data = Pred_Q[which(Pred_Q$ID%in%IDs.f),],  # To buil the appropriate plots
pch=1,cex=.8,auto.key=T, ylab="Phenotype")
RRM.1 <-mmer(Y~1                                  # mmer function from sommer package && leg() from orthopolynom package, vs = variance structure, Gu = known covariance structures
,random=~vs(leg(Time, 2),ID,Gu=GRM) + vs(leg(Time, 2), Pe)
#,rcov=~vs(units) # residuals, units = cov=~vs(ds(Time),units)
,rcov=~vs(ds(Time),units) # residuals, units = cov=~vs(ds(Time),units)
,data=Pheno)
names(RRM.1)
summary(RRM.1)
head(Pheno)
summary(RRM.1)
RnReg_Q <- rbind(unlist(RRM.1$U$`leg0:ID`),         # extract estimated random regression coeifficeints
unlist(RRM.1$U$`leg1:ID`),         # Num. regression coefficients* Num. IDs. Dim is RnReg x nID = 3 x 89
unlist(RRM.1$U$`leg2:ID`))
colnames(RnReg_Q)<- unique(Pheno$ID)                # Assign IDs to columns
Time <- unique(Pheno$Time)                         # Create a quadratic Legendre's
Phi_Q <- leg(Time, 2)
Phi_L <- Phi_Q[,-3]
RnReg_L <- RnReg_Q[-3,]
GEBV_L <- t(apply(RnReg_L, 2, function (x) Phi_L %*% x)) # estimating GEBVs for each IDs using RanReg: GEBV= Phi%*%RnReg
GEBV2_L <- t(Phi_L %*% RnReg_L)
Pred_L <- cbind(Pheno, c(RRM.1$Beta$Estimate + GEBV_L))   # merge orginal phenotype and predicted values and compare using lattice xyplot() function
colnames(Pred_L)<- c("ID", "Pe", "Time","Observed","Predicted")
IDs.f <- c(1,9,10,15,31,32,36,51,52,56,62,63)      # First 12 IDs
# Prediction using linear Leg
xyplot(Predicted+Observed~Time|ID,type ="l",       # xyplot() function from the lattice package
data = Pred_L[which(Pred_L$ID%in%IDs.f),],  # To buil the appropriate plots
pch=1, cex=1, auto.key=T, ylab="Phenotype")
GEBV_Q <- t(apply(RnReg_Q, 2, function (x) Phi_Q %*% x)) # estimating GEBVs for each IDs using RanReg: GEBV= Phi%*%RnReg
GEBV2_Q <- t(Phi_Q %*% RnReg_Q)
Pred_Q <- cbind(Pheno, c(RRM.1$Beta$Estimate + GEBV_Q))   # merge orginal phenotype and predicted values and compare using lattice xyplot() function
colnames(Pred_Q)<- c("ID", "Pe", "Time","Observed","Predicted")
xyplot(Predicted+Observed~Time|ID,type ="l",       # xyplot() function from the lattice package
data = Pred_Q[which(Pred_Q$ID%in%IDs.f),],  # To buil the appropriate plots
pch=1,cex=.8,auto.key=T, ylab="Phenotype")
RRM.1 <-mmer(Y~1                                  # mmer function from sommer package && leg() from orthopolynom package, vs = variance structure, Gu = known covariance structures
,random=~vs(leg(Time, 2),ID,Gu=GRM)
#,random=~vs(leg(Time, 2),ID,Gu=GRM) + vs(leg(Time, 2), Pe)
,rcov=~vs(units) # residuals, units = cov=~vs(ds(Time),units)
#,rcov=~vs(ds(Time),units) # residuals, units = cov=~vs(ds(Time),units)
,data=Pheno)
names(RRM.1)
summary(RRM.1)
RnReg_Q <- rbind(unlist(RRM.1$U$`leg0:ID`),         # extract estimated random regression coeifficeints
unlist(RRM.1$U$`leg1:ID`),         # Num. regression coefficients* Num. IDs. Dim is RnReg x nID = 3 x 89
unlist(RRM.1$U$`leg2:ID`))
colnames(RnReg_Q)<- unique(Pheno$ID)                # Assign IDs to columns
Time <- unique(Pheno$Time)                         # Create a quadratic Legendre's
Phi_Q <- leg(Time, 2)
Phi_L <- Phi_Q[,-3]
RnReg_L <- RnReg_Q[-3,]
GEBV_L <- t(apply(RnReg_L, 2, function (x) Phi_L %*% x)) # estimating GEBVs for each IDs using RanReg: GEBV= Phi%*%RnReg
GEBV2_L <- t(Phi_L %*% RnReg_L)
Pred_L <- cbind(Pheno, c(RRM.1$Beta$Estimate + GEBV_L))   # merge orginal phenotype and predicted values and compare using lattice xyplot() function
colnames(Pred_L)<- c("ID", "Pe", "Time","Observed","Predicted")
IDs.f <- c(1,9,10,15,31,32,36,51,52,56,62,63)      # First 12 IDs
# Prediction using linear Leg
xyplot(Predicted+Observed~Time|ID,type ="l",       # xyplot() function from the lattice package
data = Pred_L[which(Pred_L$ID%in%IDs.f),],  # To buil the appropriate plots
pch=1, cex=1, auto.key=T, ylab="Phenotype")
GEBV_Q <- t(apply(RnReg_Q, 2, function (x) Phi_Q %*% x)) # estimating GEBVs for each IDs using RanReg: GEBV= Phi%*%RnReg
GEBV2_Q <- t(Phi_Q %*% RnReg_Q)
Pred_Q <- cbind(Pheno, c(RRM.1$Beta$Estimate + GEBV_Q))   # merge orginal phenotype and predicted values and compare using lattice xyplot() function
colnames(Pred_Q)<- c("ID", "Pe", "Time","Observed","Predicted")
xyplot(Predicted+Observed~Time|ID,type ="l",       # xyplot() function from the lattice package
data = Pred_Q[which(Pred_Q$ID%in%IDs.f),],  # To buil the appropriate plots
pch=1,cex=.8,auto.key=T, ylab="Phenotype")
RRM.1 <-mmer(Y~1                                  # mmer function from sommer package && leg() from orthopolynom package, vs = variance structure, Gu = known covariance structures
,random=~vs(leg(Time, 2),ID,Gu=GRM)
#,random=~vs(leg(Time, 2),ID,Gu=GRM) + vs(leg(Time, 2), Pe)
#,rcov=~vs(units) # residuals, units = cov=~vs(ds(Time),units)
,rcov=~vs(ds(Time),units) # residuals, units = cov=~vs(ds(Time),units)
,data=Pheno)
names(RRM.1)
summary(RRM.1)
RnReg_Q <- rbind(unlist(RRM.1$U$`leg0:ID`),         # extract estimated random regression coeifficeints
unlist(RRM.1$U$`leg1:ID`),         # Num. regression coefficients* Num. IDs. Dim is RnReg x nID = 3 x 89
unlist(RRM.1$U$`leg2:ID`))
colnames(RnReg_Q)<- unique(Pheno$ID)                # Assign IDs to columns
Time <- unique(Pheno$Time)                         # Create a quadratic Legendre's
Phi_Q <- leg(Time, 2)
Phi_L <- Phi_Q[,-3]
RnReg_L <- RnReg_Q[-3,]
GEBV_L <- t(apply(RnReg_L, 2, function (x) Phi_L %*% x)) # estimating GEBVs for each IDs using RanReg: GEBV= Phi%*%RnReg
GEBV2_L <- t(Phi_L %*% RnReg_L)
Pred_L <- cbind(Pheno, c(RRM.1$Beta$Estimate + GEBV_L))   # merge orginal phenotype and predicted values and compare using lattice xyplot() function
colnames(Pred_L)<- c("ID", "Pe", "Time","Observed","Predicted")
IDs.f <- c(1,9,10,15,31,32,36,51,52,56,62,63)      # First 12 IDs
# Prediction using linear Leg
xyplot(Predicted+Observed~Time|ID,type ="l",       # xyplot() function from the lattice package
data = Pred_L[which(Pred_L$ID%in%IDs.f),],  # To buil the appropriate plots
pch=1, cex=1, auto.key=T, ylab="Phenotype")
GEBV_Q <- t(apply(RnReg_Q, 2, function (x) Phi_Q %*% x)) # estimating GEBVs for each IDs using RanReg: GEBV= Phi%*%RnReg
GEBV2_Q <- t(Phi_Q %*% RnReg_Q)
Pred_Q <- cbind(Pheno, c(RRM.1$Beta$Estimate + GEBV_Q))   # merge orginal phenotype and predicted values and compare using lattice xyplot() function
colnames(Pred_Q)<- c("ID", "Pe", "Time","Observed","Predicted")
xyplot(Predicted+Observed~Time|ID,type ="l",       # xyplot() function from the lattice package
data = Pred_Q[which(Pred_Q$ID%in%IDs.f),],  # To buil the appropriate plots
pch=1,cex=.8,auto.key=T, ylab="Phenotype")
summary(RRM.1)
